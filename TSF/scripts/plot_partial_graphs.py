import sys
import pydot
import warnings
import graphviz as gz
from trudag.dotstop.core.graph import TrustableGraph, PydotGraph
import trudag.dotstop.core.graph.graph_factory as factory
import trudag.plot as plt
from pathlib import Path

def get_my_url(vertex: str, base_url: str, full_graph: TrustableGraph) -> str:
    # This function compiles the url that is attached to a node in the custom representation of the trustable graph.
    if vertex in full_graph._graph.leaf_nodes():
        # leaf nodes are linked to their entry in the documentation
        return base_url+"/generated/"+full_graph.get_item(vertex).document+".html#"+vertex.lower()
    else:
        # non-leaf nodes are linked to their single-layer subgraphs
        return base_url+"/_images/custom_"+vertex+"_graph.svg"

def get_pydot_graph(vertices: list[str], edges: list[tuple[str,str]]) -> PydotGraph:
    # generates a PydotGraph object from a given collection of nodes and edges
    # first, test if the graph is even valid
    if any((e not in vertices) or (f not in vertices) for (e,*_,f) in edges):
        raise RuntimeError("Fatal Error: Edges may only use existing vertices.")
    # generate string in DOT language
    graph = "digraph G {"
    for vertex in vertices:
        graph += f"\"{vertex}\";"
    for source, target in edges:
        graph += f"\"{source}\" -> \"{target}\";"
    graph += "}"
    # generate PydotGraph from DOT string
    return PydotGraph.from_string(graph)

def get_subgraph(full_graph: TrustableGraph, vertices: list[str]) -> TrustableGraph:
    # generate the subgraph of full_graph spanned by a given list of vertices
    # first, test if the vertices are valid
    if any(vertex not in full_graph._graph.nodes() for vertex in vertices):
        raise RuntimeError("Fatal Error: Attempting to generate subgraph with foreign vertices!")
    # get subgraph of underlying PydotGraph
    edges = [(src,dst) for src, dst in full_graph._graph.edges() if src in vertices and dst in vertices]
    graph = get_pydot_graph(vertices,edges)
    # get items associated to vertices and generate TrustableGraph
    nodes = [full_graph.get_item(vertex) for vertex in vertices]
    return TrustableGraph(graph,nodes)

def plot_all_single_layer_subgraphs(full_graph: TrustableGraph, path: list[str], base_url: str = "") -> list[tuple[str,int]]:
    # recursively plots all "single-layer subgraphs" along a path
    # path -- expected to be list of nodes of directed path in the trustable graph whose target is the last entry
    # plots the subgraph generated by the path and the targets of all edges whose source is the target of the path
    # for each of the latter, append the path and repeat as long as there are no further targets
    # returns the list of all targets together with the list of their paths
    
    # if no path is inputted
    if len(path) == 0:
        # do nothing
        return []
    result = []
    # get most recent target
    bud = path[-1]
    # find targets that have bud as source
    new_children = full_graph._graph.successors(bud)
    # if the bud is fruitful
    if len(new_children) > 0:
        # compile subgraph that emerges from the bud
        vertices = path+new_children
        my_graph = get_subgraph(full_graph,vertices)
        # plot
        plot_blank(my_graph,full_graph,base_url,"./TSF/docs/generated/custom_"+bud+"_graph.svg")
        result.append([bud,len(path)])
        # iterate over new targets 
        for child in new_children:
            new_path = path + [child]
            result = result + plot_all_single_layer_subgraphs(full_graph,new_path,base_url)
    return result

def write_documentation(plots: list[tuple[str,int]]):
    # generates the documentation so that pictures are shown online
    # for ease of viewing, plots are sorted by length of the underlying path
    sorted_plots = sorted(plots, key=lambda x: x[1])
    for bud, length in sorted_plots:
        with open("./TSF/docs/generated/trustable_graph.rst", "a", encoding="utf-8") as documentation:
            documentation.write("\n\n.. image:: custom_"+bud+"_graph.svg\n")
            documentation.write("\t:alt: Root of the trustable graph\n\t:width: 6000px\n\n")
            documentation.write("Trustable graph centered at "+bud)

def plot_blank(graph: TrustableGraph, full_graph: TrustableGraph, base_url = "", name = "./graph.svg"):
    # plot trustable graph by hand
    # prepare the trustable graph as in trudag.plot.format_source_from_graph
    # format trustable graph for plotting purposes
    formatted_graph = pydot.graph_from_dot_data(str(graph))[0]
    formatted_graph.set("rankdir", "TB")
    formatted_graph.set("newrank", "true")
    # increase vertical distance between the nodes for improved viewing experience
    formatted_graph.set("ranksep", "2.0")

    # Remove edge and node sha's, required to support some plantuml servers.
    for element in formatted_graph.get_nodes() + formatted_graph.get_edges():
        if "sha" in element.get_attributes():
            element.get_attributes().pop("sha")

    for item in graph.items:
        # remove non-normative-nodes
        if not item.normative:
            formatted_graph.del_node(pydot.quote_id_if_necessary(str(item)))
        else:
            formatted_node = formatted_graph.get_node(
                pydot.quote_id_if_necessary(str(item))
            )[0]
            formatted_node.set("label", plt.break_line_at(item.header(), 20))
            # add custom url
            if name != "./TSF/docs/generated/TRUSTABLE-SOFTWARE.svg" or str(item) != "TRUSTABLE-SOFTWARE":
                formatted_node.set("URL", get_my_url(str(item),base_url,full_graph))
            else:
                formatted_node.set("URL", base_url+"/_images/graph.svg")    
            # Set target to avoid URLs opening within the image
            formatted_node.set("target", "_top")
            for key, value in plt.NODE_STYLE.items():
                formatted_node.set(key, value)
    # plot
    dot_source = gz.Source(formatted_graph.to_string())
    dot_source.format = 'svg'
    dot_source.render(Path(name).with_suffix(""))

def documentation_header():
    # This is the very top of trustable_graph.rst
    return """
.. _ta-analysis-subgraph:

Trustable Graph
====================

The trustable graph is the graphical representation of the argumentation.

.. image:: graph.svg
   :alt: Trustable Graph
   :width: 6000px

This image presents the full trustable graph, in which each item links to its entry in the documentation. Smaller scale representations of arguments, which are navigable among each other, can be found below. 
    """

def plot_orchestrator(full_graph: TrustableGraph, base_url: str = ""):
    # orchestrate plottage and generation of documentation
    # documentation is completely rewritten
    # initialise the documentation and overwrite obsolete data if necessary
    with open("./TSF/docs/generated/trustable_graph.rst", "w", encoding="utf-8") as documentation:
        documentation.write(documentation_header())
    # get all roots and leafs of the graph
    roots = full_graph._graph.root_nodes()
    leafs = full_graph._graph.leaf_nodes()
    for root in roots:
        # if the root is an orphaned node, discard it
        if root in leafs:
            continue
        write_documentation(plot_all_single_layer_subgraphs(full_graph,[root],base_url))

def main(base_url: str):
    # build trustable graph from .dotstop.dot
    full_trustable_graph = factory.build_trustable_graph(Path('.dotstop.dot'),Path('.'))

    # base_url is expected as argument from console execution
    plot_orchestrator(full_trustable_graph,base_url)

##########################
# Below starts the script.
##########################

if __name__ == "__main__":
    if len(sys.argv) != 2:
        base_url = ""
        warnings.warn("No base-url was transmitted. Hyperlinks amongst the partial graphs might be broken.")
    else:
        base_url = sys.argv[1]
    main(base_url)

<!DOCTYPE html>


<html lang="en" data-content_root="../../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>WFJ &#8212; NLOHMANN JSON LIBRARY  documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=4ae1632d" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/css/score.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/css/score_needs.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/css/score_design.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-data-viewer/jsonview.bundle.css?v=f6ef2277" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-needs/libs/html/datatables.min.css?v=4b4fd840" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-needs/common_css/need_links.css?v=2150a916" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-needs/common_css/need_style.css?v=92936fa5" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-needs/common_css/need_toggle.css?v=5c6620df" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-needs/common_css/needstable.css?v=5e1b6797" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-needs/common_css/need_core.css?v=f5b60a78" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-needs/modern.css?v=803738c0" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
    <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="../../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/design-tabs.js?v=f930bc37"></script>
    <script src="../../../../_static/sphinx-data-viewer/jsonview.bundle.js?v=18cd53c5"></script>
    <script src="../../../../_static/sphinx-data-viewer/jsonview_loader.js?v=f7ff7e7d"></script>
    <script src="../../../../_static/sphinx-needs/libs/html/datatables.min.js?v=8a4aee21"></script>
    <script src="../../../../_static/sphinx-needs/libs/html/datatables_loader.js?v=a2cae175"></script>
    <script src="../../../../_static/sphinx-needs/libs/html/sphinx_needs_collapse.js?v=dca66431"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 's-core/trustable/trudag/m2r2_test/WFJ';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_version = '0.16.1';
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = 'https://score-json.github.io/json/versions.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = '';
        DOCUMENTATION_OPTIONS.show_version_warning_banner =
            false;
        </script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="prev" title="TT" href="TT.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="3.12.0" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">Eclipse S-CORE</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../introduction/index.html">
    Introduction
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../concept.html">
    Concept
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../tenets/index.html">
    Trustable Tenets
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../report.html">
    Report
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://projects.eclipse.org/projects/automotive.score">
    Eclipse
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/eclipse-score" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
      
        <div class="navbar-item">
<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-2"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-2"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-2"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-2">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../introduction/index.html">
    Introduction
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../concept.html">
    Concept
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../tenets/index.html">
    Trustable Tenets
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../report.html">
    Report
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://projects.eclipse.org/projects/automotive.score">
    Eclipse
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/eclipse-score" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
        
          <div class="navbar-item">
<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-3"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-3"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-3"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-3">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"></div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../report.html" class="nav-link">Report</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">WFJ</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="wfj">
<h1>WFJ<a class="headerlink" href="#wfj" title="Link to this heading">#</a></h1>
<section id="wfj-01">
<span id="id1"></span><h2>WFJ-01<a class="headerlink" href="#wfj-01" title="Link to this heading">#</a></h2>
<p>The service checks for the four primitive types (strings, numbers, booleans, null).
{: .expanded-item-element }</p>
<p><strong>Supported Requests:</strong></p>
<ul class="simple">
<li><p><a class="reference internal" href="TA.html#ta-behaviours"><span class="std std-ref">TA-BEHAVIOURS</span></a></p></li>
</ul>
<p><strong>Supporting Items:</strong></p>
<p><em>None</em></p>
<p>{% raw %}</p>
<p><strong>References:</strong></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">nlohmann_json/tests/src/unit-class_parser.cpp</span></code></p>
<blockquote>
<div><p>??? ‚ÄúClick to view reference‚Äù</p>
</div></blockquote>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>````cpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++ (supporting code)
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann &lt;https://nlohmann.me&gt;
// SPDX-License-Identifier: MIT

#include &quot;doctest_compatibility.h&quot;

#define JSON_TESTS_PRIVATE
#include &lt;nlohmann/json.hpp&gt;
using nlohmann::json;
#ifdef JSON_TEST_NO_GLOBAL_UDLS
    using namespace nlohmann::literals; // NOLINT(google-build-using-namespace)
#endif

#include &lt;valarray&gt;

namespace
{
class SaxEventLogger
{
  public:
    bool null()
    {
        events.emplace_back(&quot;null()&quot;);
        return true;
    }

    bool boolean(bool val)
    {
        events.emplace_back(val ? &quot;boolean(true)&quot; : &quot;boolean(false)&quot;);
        return true;
    }

    bool number_integer(json::number_integer_t val)
    {
        events.push_back(&quot;number_integer(&quot; + std::to_string(val) + &quot;)&quot;);
        return true;
    }

    bool number_unsigned(json::number_unsigned_t val)
    {
        events.push_back(&quot;number_unsigned(&quot; + std::to_string(val) + &quot;)&quot;);
        return true;
    }

    bool number_float(json::number_float_t /*unused*/, const std::string&amp; s)
    {
        events.push_back(&quot;number_float(&quot; + s + &quot;)&quot;);
        return true;
    }

    bool string(std::string&amp; val)
    {
        events.push_back(&quot;string(&quot; + val + &quot;)&quot;);
        return true;
    }

    bool binary(json::binary_t&amp; val)
    {
        std::string binary_contents = &quot;binary(&quot;;
        std::string comma_space;
        for (auto b : val)
        {
            binary_contents.append(comma_space);
            binary_contents.append(std::to_string(static_cast&lt;int&gt;(b)));
            comma_space = &quot;, &quot;;
        }
        binary_contents.append(&quot;)&quot;);
        events.push_back(binary_contents);
        return true;
    }

    bool start_object(std::size_t elements)
    {
        if (elements == (std::numeric_limits&lt;std::size_t&gt;::max)())
        {
            events.emplace_back(&quot;start_object()&quot;);
        }
        else
        {
            events.push_back(&quot;start_object(&quot; + std::to_string(elements) + &quot;)&quot;);
        }
        return true;
    }

    bool key(std::string&amp; val)
    {
        events.push_back(&quot;key(&quot; + val + &quot;)&quot;);
        return true;
    }

    bool end_object()
    {
        events.emplace_back(&quot;end_object()&quot;);
        return true;
    }

    bool start_array(std::size_t elements)
    {
        if (elements == (std::numeric_limits&lt;std::size_t&gt;::max)())
        {
            events.emplace_back(&quot;start_array()&quot;);
        }
        else
        {
            events.push_back(&quot;start_array(&quot; + std::to_string(elements) + &quot;)&quot;);
        }
        return true;
    }

    bool end_array()
    {
        events.emplace_back(&quot;end_array()&quot;);
        return true;
    }

    bool parse_error(std::size_t position, const std::string&amp; /*unused*/, const json::exception&amp; /*unused*/)
    {
        errored = true;
        events.push_back(&quot;parse_error(&quot; + std::to_string(position) + &quot;)&quot;);
        return false;
    }

    std::vector&lt;std::string&gt; events {}; // NOLINT(readability-redundant-member-init)
    bool errored = false;
};

class SaxCountdown : public nlohmann::json::json_sax_t
{
  public:
    explicit SaxCountdown(const int count) : events_left(count)
    {}

    bool null() override
    {
        return events_left-- &gt; 0;
    }

    bool boolean(bool /*val*/) override
    {
        return events_left-- &gt; 0;
    }

    bool number_integer(json::number_integer_t /*val*/) override
    {
        return events_left-- &gt; 0;
    }

    bool number_unsigned(json::number_unsigned_t /*val*/) override
    {
        return events_left-- &gt; 0;
    }

    bool number_float(json::number_float_t /*val*/, const std::string&amp; /*s*/) override
    {
        return events_left-- &gt; 0;
    }

    bool string(std::string&amp; /*val*/) override
    {
        return events_left-- &gt; 0;
    }

    bool binary(json::binary_t&amp; /*val*/) override
    {
        return events_left-- &gt; 0;
    }

    bool start_object(std::size_t /*elements*/) override
    {
        return events_left-- &gt; 0;
    }

    bool key(std::string&amp; /*val*/) override
    {
        return events_left-- &gt; 0;
    }

    bool end_object() override
    {
        return events_left-- &gt; 0;
    }

    bool start_array(std::size_t /*elements*/) override
    {
        return events_left-- &gt; 0;
    }

    bool end_array() override
    {
        return events_left-- &gt; 0;
    }

    bool parse_error(std::size_t /*position*/, const std::string&amp; /*last_token*/, const json::exception&amp; /*ex*/) override
    {
        return false;
    }

  private:
    int events_left = 0;
};

json parser_helper(const std::string&amp; s);
bool accept_helper(const std::string&amp; s);
void comments_helper(const std::string&amp; s);

json parser_helper(const std::string&amp; s)
{
    json j;
    json::parser(nlohmann::detail::input_adapter(s)).parse(true, j);

    // if this line was reached, no exception occurred
    // -&gt; check if result is the same without exceptions
    json j_nothrow;
    CHECK_NOTHROW(json::parser(nlohmann::detail::input_adapter(s), nullptr, false).parse(true, j_nothrow));
    CHECK(j_nothrow == j);

    json j_sax;
    nlohmann::detail::json_sax_dom_parser&lt;json, nlohmann::detail::string_input_adapter_type&gt; sdp(j_sax);
    json::sax_parse(s, &amp;sdp);
    CHECK(j_sax == j);

    comments_helper(s);

    return j;
}

bool accept_helper(const std::string&amp; s)
{
    CAPTURE(s)

    // 1. parse s without exceptions
    json j;
    CHECK_NOTHROW(json::parser(nlohmann::detail::input_adapter(s), nullptr, false).parse(true, j));
    const bool ok_noexcept = !j.is_discarded();

    // 2. accept s
    const bool ok_accept = json::parser(nlohmann::detail::input_adapter(s)).accept(true);

    // 3. check if both approaches come to the same result
    CHECK(ok_noexcept == ok_accept);

    // 4. parse with SAX (compare with relaxed accept result)
    SaxEventLogger el;
    CHECK_NOTHROW(json::sax_parse(s, &amp;el, json::input_format_t::json, false));
    CHECK(json::parser(nlohmann::detail::input_adapter(s)).accept(false) == !el.errored);

    // 5. parse with simple callback
    json::parser_callback_t const cb = [](int /*unused*/, json::parse_event_t /*unused*/, json&amp; /*unused*/) noexcept
    {
        return true;
    };
    json const j_cb = json::parse(s, cb, false);
    const bool ok_noexcept_cb = !j_cb.is_discarded();

    // 6. check if this approach came to the same result
    CHECK(ok_noexcept == ok_noexcept_cb);

    // 7. check if comments are properly ignored
    if (ok_accept)
    {
        comments_helper(s);
    }

    // 8. return result
    return ok_accept;
}

void comments_helper(const std::string&amp; s)
{
    json _;

    // parse/accept with default parser
    CHECK_NOTHROW(_ = json::parse(s));
    CHECK(json::accept(s));

    // parse/accept while skipping comments
    CHECK_NOTHROW(_ = json::parse(s, nullptr, false, true));
    CHECK(json::accept(s, true));

    std::vector&lt;std::string&gt; json_with_comments;

    // start with a comment
    json_with_comments.push_back(std::string(&quot;// this is a comment\n&quot;) + s);
    json_with_comments.push_back(std::string(&quot;/* this is a comment */&quot;) + s);
    // end with a comment
    json_with_comments.push_back(s + &quot;// this is a comment&quot;);
    json_with_comments.push_back(s + &quot;/* this is a comment */&quot;);

    // check all strings
    for (const auto&amp; json_with_comment : json_with_comments)
    {
        CAPTURE(json_with_comment)
        CHECK_THROWS_AS(_ = json::parse(json_with_comment), json::parse_error);
        CHECK(!json::accept(json_with_comment));

        CHECK_NOTHROW(_ = json::parse(json_with_comment, nullptr, true, true));
        CHECK(json::accept(json_with_comment, true));
    }
}

} // namespace

TEST_CASE(&quot;parser class&quot;)
{
    SECTION(&quot;parse&quot;)
    {
        SECTION(&quot;null&quot;)
        {
            CHECK(parser_helper(&quot;null&quot;) == json(nullptr));
        }

        SECTION(&quot;true&quot;)
        {
            CHECK(parser_helper(&quot;true&quot;) == json(true));
        }

        SECTION(&quot;false&quot;)
        {
            CHECK(parser_helper(&quot;false&quot;) == json(false));
        }

        SECTION(&quot;array&quot;)
        {
            SECTION(&quot;empty array&quot;)
            {
                CHECK(parser_helper(&quot;[]&quot;) == json(json::value_t::array));
                CHECK(parser_helper(&quot;[ ]&quot;) == json(json::value_t::array));
            }

            SECTION(&quot;nonempty array&quot;)
            {
                CHECK(parser_helper(&quot;[true, false, null]&quot;) == json({true, false, nullptr}));
            }
        }

        SECTION(&quot;object&quot;)
        {
            SECTION(&quot;empty object&quot;)
            {
                CHECK(parser_helper(&quot;{}&quot;) == json(json::value_t::object));
                CHECK(parser_helper(&quot;{ }&quot;) == json(json::value_t::object));
            }

            SECTION(&quot;nonempty object&quot;)
            {
                CHECK(parser_helper(&quot;{\&quot;\&quot;: true, \&quot;one\&quot;: 1, \&quot;two\&quot;: null}&quot;) == json({{&quot;&quot;, true}, {&quot;one&quot;, 1}, {&quot;two&quot;, nullptr}}));
            }
        }

        SECTION(&quot;string&quot;)
        {
            // empty string
            CHECK(parser_helper(&quot;\&quot;\&quot;&quot;) == json(json::value_t::string));

            SECTION(&quot;errors&quot;)
            {
                // error: tab in string
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\t\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0009 (HT) must be escaped to \\u0009 or \\t; last read: &#39;\&quot;&lt;U+0009&gt;&#39;&quot;, json::parse_error&amp;);
                // error: newline in string
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\n\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 2, column 0: syntax error while parsing value - invalid string: control character U+000A (LF) must be escaped to \\u000A or \\n; last read: &#39;\&quot;&lt;U+000A&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\r\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+000D (CR) must be escaped to \\u000D or \\r; last read: &#39;\&quot;&lt;U+000D&gt;&#39;&quot;, json::parse_error&amp;);
                // error: backspace in string
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\b\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0008 (BS) must be escaped to \\u0008 or \\b; last read: &#39;\&quot;&lt;U+0008&gt;&#39;&quot;, json::parse_error&amp;);
                // improve code coverage
                CHECK_THROWS_AS(parser_helper(&quot;\uFF01&quot;), json::parse_error&amp;);
                CHECK_THROWS_AS(parser_helper(&quot;[-4:1,]&quot;), json::parse_error&amp;);
                // unescaped control characters
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x00\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: missing closing quote; last read: &#39;\&quot;&#39;&quot;, json::parse_error&amp;); // NOLINT(bugprone-string-literal-with-embedded-nul)
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x01\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0001 (SOH) must be escaped to \\u0001; last read: &#39;\&quot;&lt;U+0001&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x02\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0002 (STX) must be escaped to \\u0002; last read: &#39;\&quot;&lt;U+0002&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x03\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0003 (ETX) must be escaped to \\u0003; last read: &#39;\&quot;&lt;U+0003&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x04\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0004 (EOT) must be escaped to \\u0004; last read: &#39;\&quot;&lt;U+0004&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x05\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0005 (ENQ) must be escaped to \\u0005; last read: &#39;\&quot;&lt;U+0005&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x06\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0006 (ACK) must be escaped to \\u0006; last read: &#39;\&quot;&lt;U+0006&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x07\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0007 (BEL) must be escaped to \\u0007; last read: &#39;\&quot;&lt;U+0007&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x08\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0008 (BS) must be escaped to \\u0008 or \\b; last read: &#39;\&quot;&lt;U+0008&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x09\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0009 (HT) must be escaped to \\u0009 or \\t; last read: &#39;\&quot;&lt;U+0009&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x0a\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 2, column 0: syntax error while parsing value - invalid string: control character U+000A (LF) must be escaped to \\u000A or \\n; last read: &#39;\&quot;&lt;U+000A&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x0b\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+000B (VT) must be escaped to \\u000B; last read: &#39;\&quot;&lt;U+000B&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x0c\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+000C (FF) must be escaped to \\u000C or \\f; last read: &#39;\&quot;&lt;U+000C&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x0d\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+000D (CR) must be escaped to \\u000D or \\r; last read: &#39;\&quot;&lt;U+000D&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x0e\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+000E (SO) must be escaped to \\u000E; last read: &#39;\&quot;&lt;U+000E&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x0f\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+000F (SI) must be escaped to \\u000F; last read: &#39;\&quot;&lt;U+000F&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x10\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0010 (DLE) must be escaped to \\u0010; last read: &#39;\&quot;&lt;U+0010&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x11\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0011 (DC1) must be escaped to \\u0011; last read: &#39;\&quot;&lt;U+0011&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x12\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0012 (DC2) must be escaped to \\u0012; last read: &#39;\&quot;&lt;U+0012&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x13\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0013 (DC3) must be escaped to \\u0013; last read: &#39;\&quot;&lt;U+0013&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x14\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0014 (DC4) must be escaped to \\u0014; last read: &#39;\&quot;&lt;U+0014&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x15\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0015 (NAK) must be escaped to \\u0015; last read: &#39;\&quot;&lt;U+0015&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x16\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0016 (SYN) must be escaped to \\u0016; last read: &#39;\&quot;&lt;U+0016&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x17\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0017 (ETB) must be escaped to \\u0017; last read: &#39;\&quot;&lt;U+0017&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x18\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0018 (CAN) must be escaped to \\u0018; last read: &#39;\&quot;&lt;U+0018&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x19\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0019 (EM) must be escaped to \\u0019; last read: &#39;\&quot;&lt;U+0019&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x1a\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+001A (SUB) must be escaped to \\u001A; last read: &#39;\&quot;&lt;U+001A&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x1b\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+001B (ESC) must be escaped to \\u001B; last read: &#39;\&quot;&lt;U+001B&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x1c\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+001C (FS) must be escaped to \\u001C; last read: &#39;\&quot;&lt;U+001C&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x1d\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+001D (GS) must be escaped to \\u001D; last read: &#39;\&quot;&lt;U+001D&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x1e\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+001E (RS) must be escaped to \\u001E; last read: &#39;\&quot;&lt;U+001E&gt;&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\x1f\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+001F (US) must be escaped to \\u001F; last read: &#39;\&quot;&lt;U+001F&gt;&#39;&quot;, json::parse_error&amp;);

                SECTION(&quot;additional test for null byte&quot;)
                {
                    // The test above for the null byte is wrong, because passing
                    // a string to the parser only reads int until it encounters
                    // a null byte. This test inserts the null byte later on and
                    // uses an iterator range.
                    std::string s = &quot;\&quot;1\&quot;&quot;;
                    s[1] = &#39;\0&#39;;
                    json _;
                    CHECK_THROWS_WITH_AS(_ = json::parse(s.begin(), s.end()), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0000 (NUL) must be escaped to \\u0000; last read: &#39;\&quot;&lt;U+0000&gt;&#39;&quot;, json::parse_error&amp;);
                }
            }

            SECTION(&quot;escaped&quot;)
            {
                // quotation mark &quot;\&quot;&quot;
                auto r1 = R&quot;(&quot;\&quot;&quot;)&quot;_json;
                CHECK(parser_helper(&quot;\&quot;\\\&quot;\&quot;&quot;) == r1);
                // reverse solidus &quot;\\&quot;
                auto r2 = R&quot;(&quot;\\&quot;)&quot;_json;
                CHECK(parser_helper(&quot;\&quot;\\\\\&quot;&quot;) == r2);
                // solidus
                CHECK(parser_helper(&quot;\&quot;\\/\&quot;&quot;) == R&quot;(&quot;/&quot;)&quot;_json);
                // backspace
                CHECK(parser_helper(&quot;\&quot;\\b\&quot;&quot;) == json(&quot;\b&quot;));
                // formfeed
                CHECK(parser_helper(&quot;\&quot;\\f\&quot;&quot;) == json(&quot;\f&quot;));
                // newline
                CHECK(parser_helper(&quot;\&quot;\\n\&quot;&quot;) == json(&quot;\n&quot;));
                // carriage return
                CHECK(parser_helper(&quot;\&quot;\\r\&quot;&quot;) == json(&quot;\r&quot;));
                // horizontal tab
                CHECK(parser_helper(&quot;\&quot;\\t\&quot;&quot;) == json(&quot;\t&quot;));

                CHECK(parser_helper(&quot;\&quot;\\u0001\&quot;&quot;).get&lt;json::string_t&gt;() == &quot;\x01&quot;);
                CHECK(parser_helper(&quot;\&quot;\\u000a\&quot;&quot;).get&lt;json::string_t&gt;() == &quot;\n&quot;);
                CHECK(parser_helper(&quot;\&quot;\\u00b0\&quot;&quot;).get&lt;json::string_t&gt;() == &quot;¬∞&quot;);
                CHECK(parser_helper(&quot;\&quot;\\u0c00\&quot;&quot;).get&lt;json::string_t&gt;() == &quot;‡∞Ä&quot;);
                CHECK(parser_helper(&quot;\&quot;\\ud000\&quot;&quot;).get&lt;json::string_t&gt;() == &quot;ÌÄÄ&quot;);
                CHECK(parser_helper(&quot;\&quot;\\u000E\&quot;&quot;).get&lt;json::string_t&gt;() == &quot;\x0E&quot;);
                CHECK(parser_helper(&quot;\&quot;\\u00F0\&quot;&quot;).get&lt;json::string_t&gt;() == &quot;√∞&quot;);
                CHECK(parser_helper(&quot;\&quot;\\u0100\&quot;&quot;).get&lt;json::string_t&gt;() == &quot;ƒÄ&quot;);
                CHECK(parser_helper(&quot;\&quot;\\u2000\&quot;&quot;).get&lt;json::string_t&gt;() == &quot;‚ÄÄ&quot;);
                CHECK(parser_helper(&quot;\&quot;\\uFFFF\&quot;&quot;).get&lt;json::string_t&gt;() == &quot;Ôøø&quot;);
                CHECK(parser_helper(&quot;\&quot;\\u20AC\&quot;&quot;).get&lt;json::string_t&gt;() == &quot;‚Ç¨&quot;);
                CHECK(parser_helper(&quot;\&quot;‚Ç¨\&quot;&quot;).get&lt;json::string_t&gt;() == &quot;‚Ç¨&quot;);
                CHECK(parser_helper(&quot;\&quot;üéà\&quot;&quot;).get&lt;json::string_t&gt;() == &quot;üéà&quot;);

                CHECK(parser_helper(&quot;\&quot;\\ud80c\\udc60\&quot;&quot;).get&lt;json::string_t&gt;() == &quot;\xf0\x93\x81\xa0&quot;);
                CHECK(parser_helper(&quot;\&quot;\\ud83c\\udf1e\&quot;&quot;).get&lt;json::string_t&gt;() == &quot;üåû&quot;);
            }
        }

        SECTION(&quot;number&quot;)
        {
            SECTION(&quot;integers&quot;)
            {
                SECTION(&quot;without exponent&quot;)
                {
                    CHECK(parser_helper(&quot;-128&quot;) == json(-128));
                    CHECK(parser_helper(&quot;-0&quot;) == json(-0));
                    CHECK(parser_helper(&quot;0&quot;) == json(0));
                    CHECK(parser_helper(&quot;128&quot;) == json(128));
                }

                SECTION(&quot;with exponent&quot;)
                {
                    CHECK(parser_helper(&quot;0e1&quot;) == json(0e1));
                    CHECK(parser_helper(&quot;0E1&quot;) == json(0e1));

                    CHECK(parser_helper(&quot;10000E-4&quot;) == json(10000e-4));
                    CHECK(parser_helper(&quot;10000E-3&quot;) == json(10000e-3));
                    CHECK(parser_helper(&quot;10000E-2&quot;) == json(10000e-2));
                    CHECK(parser_helper(&quot;10000E-1&quot;) == json(10000e-1));
                    CHECK(parser_helper(&quot;10000E0&quot;) == json(10000e0));
                    CHECK(parser_helper(&quot;10000E1&quot;) == json(10000e1));
                    CHECK(parser_helper(&quot;10000E2&quot;) == json(10000e2));
                    CHECK(parser_helper(&quot;10000E3&quot;) == json(10000e3));
                    CHECK(parser_helper(&quot;10000E4&quot;) == json(10000e4));

                    CHECK(parser_helper(&quot;10000e-4&quot;) == json(10000e-4));
                    CHECK(parser_helper(&quot;10000e-3&quot;) == json(10000e-3));
                    CHECK(parser_helper(&quot;10000e-2&quot;) == json(10000e-2));
                    CHECK(parser_helper(&quot;10000e-1&quot;) == json(10000e-1));
                    CHECK(parser_helper(&quot;10000e0&quot;) == json(10000e0));
                    CHECK(parser_helper(&quot;10000e1&quot;) == json(10000e1));
                    CHECK(parser_helper(&quot;10000e2&quot;) == json(10000e2));
                    CHECK(parser_helper(&quot;10000e3&quot;) == json(10000e3));
                    CHECK(parser_helper(&quot;10000e4&quot;) == json(10000e4));

                    CHECK(parser_helper(&quot;-0e1&quot;) == json(-0e1));
                    CHECK(parser_helper(&quot;-0E1&quot;) == json(-0e1));
                    CHECK(parser_helper(&quot;-0E123&quot;) == json(-0e123));

                    // numbers after exponent
                    CHECK(parser_helper(&quot;10E0&quot;) == json(10e0));
                    CHECK(parser_helper(&quot;10E1&quot;) == json(10e1));
                    CHECK(parser_helper(&quot;10E2&quot;) == json(10e2));
                    CHECK(parser_helper(&quot;10E3&quot;) == json(10e3));
                    CHECK(parser_helper(&quot;10E4&quot;) == json(10e4));
                    CHECK(parser_helper(&quot;10E5&quot;) == json(10e5));
                    CHECK(parser_helper(&quot;10E6&quot;) == json(10e6));
                    CHECK(parser_helper(&quot;10E7&quot;) == json(10e7));
                    CHECK(parser_helper(&quot;10E8&quot;) == json(10e8));
                    CHECK(parser_helper(&quot;10E9&quot;) == json(10e9));
                    CHECK(parser_helper(&quot;10E+0&quot;) == json(10e0));
                    CHECK(parser_helper(&quot;10E+1&quot;) == json(10e1));
                    CHECK(parser_helper(&quot;10E+2&quot;) == json(10e2));
                    CHECK(parser_helper(&quot;10E+3&quot;) == json(10e3));
                    CHECK(parser_helper(&quot;10E+4&quot;) == json(10e4));
                    CHECK(parser_helper(&quot;10E+5&quot;) == json(10e5));
                    CHECK(parser_helper(&quot;10E+6&quot;) == json(10e6));
                    CHECK(parser_helper(&quot;10E+7&quot;) == json(10e7));
                    CHECK(parser_helper(&quot;10E+8&quot;) == json(10e8));
                    CHECK(parser_helper(&quot;10E+9&quot;) == json(10e9));
                    CHECK(parser_helper(&quot;10E-1&quot;) == json(10e-1));
                    CHECK(parser_helper(&quot;10E-2&quot;) == json(10e-2));
                    CHECK(parser_helper(&quot;10E-3&quot;) == json(10e-3));
                    CHECK(parser_helper(&quot;10E-4&quot;) == json(10e-4));
                    CHECK(parser_helper(&quot;10E-5&quot;) == json(10e-5));
                    CHECK(parser_helper(&quot;10E-6&quot;) == json(10e-6));
                    CHECK(parser_helper(&quot;10E-7&quot;) == json(10e-7));
                    CHECK(parser_helper(&quot;10E-8&quot;) == json(10e-8));
                    CHECK(parser_helper(&quot;10E-9&quot;) == json(10e-9));
                }

                SECTION(&quot;edge cases&quot;)
                {
                    // From RFC8259, Section 6:
                    // Note that when such software is used, numbers that are
                    // integers and are in the range [-(2**53)+1, (2**53)-1]
                    // are interoperable in the sense that implementations will
                    // agree exactly on their numeric values.

                    // -(2**53)+1
                    CHECK(parser_helper(&quot;-9007199254740991&quot;).get&lt;int64_t&gt;() == -9007199254740991);
                    // (2**53)-1
                    CHECK(parser_helper(&quot;9007199254740991&quot;).get&lt;int64_t&gt;() == 9007199254740991);
                }

                SECTION(&quot;over the edge cases&quot;)  // issue #178 - Integer conversion to unsigned (incorrect handling of 64-bit integers)
                {
                    // While RFC8259, Section 6 specifies a preference for support
                    // for ranges in range of IEEE 754-2008 binary64 (double precision)
                    // this does not accommodate 64-bit integers without loss of accuracy.
                    // As 64-bit integers are now widely used in software, it is desirable
                    // to expand support to the full 64 bit (signed and unsigned) range
                    // i.e. -(2**63) -&gt; (2**64)-1.

                    // -(2**63)    ** Note: compilers see negative literals as negated positive numbers (hence the -1))
                    CHECK(parser_helper(&quot;-9223372036854775808&quot;).get&lt;int64_t&gt;() == -9223372036854775807 - 1);
                    // (2**63)-1
                    CHECK(parser_helper(&quot;9223372036854775807&quot;).get&lt;int64_t&gt;() == 9223372036854775807);
                    // (2**64)-1
                    CHECK(parser_helper(&quot;18446744073709551615&quot;).get&lt;uint64_t&gt;() == 18446744073709551615u);
                }
            }

            SECTION(&quot;floating-point&quot;)
            {
                SECTION(&quot;without exponent&quot;)
                {
                    CHECK(parser_helper(&quot;-128.5&quot;) == json(-128.5));
                    CHECK(parser_helper(&quot;0.999&quot;) == json(0.999));
                    CHECK(parser_helper(&quot;128.5&quot;) == json(128.5));
                    CHECK(parser_helper(&quot;-0.0&quot;) == json(-0.0));
                }

                SECTION(&quot;with exponent&quot;)
                {
                    CHECK(parser_helper(&quot;-128.5E3&quot;) == json(-128.5E3));
                    CHECK(parser_helper(&quot;-128.5E-3&quot;) == json(-128.5E-3));
                    CHECK(parser_helper(&quot;-0.0e1&quot;) == json(-0.0e1));
                    CHECK(parser_helper(&quot;-0.0E1&quot;) == json(-0.0e1));
                }
            }

            SECTION(&quot;overflow&quot;)
            {
                // overflows during parsing yield an exception
                CHECK_THROWS_WITH_AS(parser_helper(&quot;1.18973e+4932&quot;).empty(), &quot;[json.exception.out_of_range.406] number overflow parsing &#39;1.18973e+4932&#39;&quot;, json::out_of_range&amp;);
            }

            SECTION(&quot;invalid numbers&quot;)
            {
                // numbers must not begin with &quot;+&quot;
                CHECK_THROWS_AS(parser_helper(&quot;+1&quot;), json::parse_error&amp;);
                CHECK_THROWS_AS(parser_helper(&quot;+0&quot;), json::parse_error&amp;);

                CHECK_THROWS_WITH_AS(parser_helper(&quot;01&quot;),
                                     &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - unexpected number literal; expected end of input&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;-01&quot;),
                                     &quot;[json.exception.parse_error.101] parse error at line 1, column 3: syntax error while parsing value - unexpected number literal; expected end of input&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;--1&quot;),
                                     &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid number; expected digit after &#39;-&#39;; last read: &#39;--&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;1.&quot;),
                                     &quot;[json.exception.parse_error.101] parse error at line 1, column 3: syntax error while parsing value - invalid number; expected digit after &#39;.&#39;; last read: &#39;1.&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;1E&quot;),
                                     &quot;[json.exception.parse_error.101] parse error at line 1, column 3: syntax error while parsing value - invalid number; expected &#39;+&#39;, &#39;-&#39;, or digit after exponent; last read: &#39;1E&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;1E-&quot;),
                                     &quot;[json.exception.parse_error.101] parse error at line 1, column 4: syntax error while parsing value - invalid number; expected digit after exponent sign; last read: &#39;1E-&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;1.E1&quot;),
                                     &quot;[json.exception.parse_error.101] parse error at line 1, column 3: syntax error while parsing value - invalid number; expected digit after &#39;.&#39;; last read: &#39;1.E&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;-1E&quot;),
                                     &quot;[json.exception.parse_error.101] parse error at line 1, column 4: syntax error while parsing value - invalid number; expected &#39;+&#39;, &#39;-&#39;, or digit after exponent; last read: &#39;-1E&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;-0E#&quot;),
                                     &quot;[json.exception.parse_error.101] parse error at line 1, column 4: syntax error while parsing value - invalid number; expected &#39;+&#39;, &#39;-&#39;, or digit after exponent; last read: &#39;-0E#&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;-0E-#&quot;),
                                     &quot;[json.exception.parse_error.101] parse error at line 1, column 5: syntax error while parsing value - invalid number; expected digit after exponent sign; last read: &#39;-0E-#&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;-0#&quot;),
                                     &quot;[json.exception.parse_error.101] parse error at line 1, column 3: syntax error while parsing value - invalid literal; last read: &#39;-0#&#39;; expected end of input&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;-0.0:&quot;),
                                     &quot;[json.exception.parse_error.101] parse error at line 1, column 5: syntax error while parsing value - unexpected &#39;:&#39;; expected end of input&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;-0.0Z&quot;),
                                     &quot;[json.exception.parse_error.101] parse error at line 1, column 5: syntax error while parsing value - invalid literal; last read: &#39;-0.0Z&#39;; expected end of input&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;-0E123:&quot;),
                                     &quot;[json.exception.parse_error.101] parse error at line 1, column 7: syntax error while parsing value - unexpected &#39;:&#39;; expected end of input&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;-0e0-:&quot;),
                                     &quot;[json.exception.parse_error.101] parse error at line 1, column 6: syntax error while parsing value - invalid number; expected digit after &#39;-&#39;; last read: &#39;-:&#39;; expected end of input&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;-0e-:&quot;),
                                     &quot;[json.exception.parse_error.101] parse error at line 1, column 5: syntax error while parsing value - invalid number; expected digit after exponent sign; last read: &#39;-0e-:&#39;&quot;, json::parse_error&amp;);
                CHECK_THROWS_WITH_AS(parser_helper(&quot;-0f&quot;),
                                     &quot;[json.exception.parse_error.101] parse error at line 1, column 4: syntax error while parsing value - invalid literal; last read: &#39;-0f&#39;; expected end of input&quot;, json::parse_error&amp;);
            }
        }
    }

    SECTION(&quot;accept&quot;)
    {
        SECTION(&quot;null&quot;)
        {
            CHECK(accept_helper(&quot;null&quot;));
        }

        SECTION(&quot;true&quot;)
        {
            CHECK(accept_helper(&quot;true&quot;));
        }

        SECTION(&quot;false&quot;)
        {
            CHECK(accept_helper(&quot;false&quot;));
        }

        SECTION(&quot;array&quot;)
        {
            SECTION(&quot;empty array&quot;)
            {
                CHECK(accept_helper(&quot;[]&quot;));
                CHECK(accept_helper(&quot;[ ]&quot;));
            }

            SECTION(&quot;nonempty array&quot;)
            {
                CHECK(accept_helper(&quot;[true, false, null]&quot;));
            }
        }

        SECTION(&quot;object&quot;)
        {
            SECTION(&quot;empty object&quot;)
            {
                CHECK(accept_helper(&quot;{}&quot;));
                CHECK(accept_helper(&quot;{ }&quot;));
            }

            SECTION(&quot;nonempty object&quot;)
            {
                CHECK(accept_helper(&quot;{\&quot;\&quot;: true, \&quot;one\&quot;: 1, \&quot;two\&quot;: null}&quot;));
            }
        }

        SECTION(&quot;string&quot;)
        {
            // empty string
            CHECK(accept_helper(&quot;\&quot;\&quot;&quot;));

            SECTION(&quot;errors&quot;)
            {
                // error: tab in string
                CHECK(accept_helper(&quot;\&quot;\t\&quot;&quot;) == false);
                // error: newline in string
                CHECK(accept_helper(&quot;\&quot;\n\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\r\&quot;&quot;) == false);
                // error: backspace in string
                CHECK(accept_helper(&quot;\&quot;\b\&quot;&quot;) == false);
                // improve code coverage
                CHECK(accept_helper(&quot;\uFF01&quot;) == false);
                CHECK(accept_helper(&quot;[-4:1,]&quot;) == false);
                // unescaped control characters
                CHECK(accept_helper(&quot;\&quot;\x00\&quot;&quot;) == false); // NOLINT(bugprone-string-literal-with-embedded-nul)
                CHECK(accept_helper(&quot;\&quot;\x01\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x02\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x03\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x04\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x05\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x06\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x07\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x08\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x09\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x0a\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x0b\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x0c\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x0d\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x0e\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x0f\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x10\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x11\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x12\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x13\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x14\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x15\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x16\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x17\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x18\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x19\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x1a\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x1b\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x1c\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x1d\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x1e\&quot;&quot;) == false);
                CHECK(accept_helper(&quot;\&quot;\x1f\&quot;&quot;) == false);
            }

            SECTION(&quot;escaped&quot;)
            {
                // quotation mark &quot;\&quot;&quot;
                auto r1 = R&quot;(&quot;\&quot;&quot;)&quot;_json;
                CHECK(accept_helper(&quot;\&quot;\\\&quot;\&quot;&quot;));
                // reverse solidus &quot;\\&quot;
                auto r2 = R&quot;(&quot;\\&quot;)&quot;_json;
                CHECK(accept_helper(&quot;\&quot;\\\\\&quot;&quot;));
                // solidus
                CHECK(accept_helper(&quot;\&quot;\\/\&quot;&quot;));
                // backspace
                CHECK(accept_helper(&quot;\&quot;\\b\&quot;&quot;));
                // formfeed
                CHECK(accept_helper(&quot;\&quot;\\f\&quot;&quot;));
                // newline
                CHECK(accept_helper(&quot;\&quot;\\n\&quot;&quot;));
                // carriage return
                CHECK(accept_helper(&quot;\&quot;\\r\&quot;&quot;));
                // horizontal tab
                CHECK(accept_helper(&quot;\&quot;\\t\&quot;&quot;));

                CHECK(accept_helper(&quot;\&quot;\\u0001\&quot;&quot;));
                CHECK(accept_helper(&quot;\&quot;\\u000a\&quot;&quot;));
                CHECK(accept_helper(&quot;\&quot;\\u00b0\&quot;&quot;));
                CHECK(accept_helper(&quot;\&quot;\\u0c00\&quot;&quot;));
                CHECK(accept_helper(&quot;\&quot;\\ud000\&quot;&quot;));
                CHECK(accept_helper(&quot;\&quot;\\u000E\&quot;&quot;));
                CHECK(accept_helper(&quot;\&quot;\\u00F0\&quot;&quot;));
                CHECK(accept_helper(&quot;\&quot;\\u0100\&quot;&quot;));
                CHECK(accept_helper(&quot;\&quot;\\u2000\&quot;&quot;));
                CHECK(accept_helper(&quot;\&quot;\\uFFFF\&quot;&quot;));
                CHECK(accept_helper(&quot;\&quot;\\u20AC\&quot;&quot;));
                CHECK(accept_helper(&quot;\&quot;‚Ç¨\&quot;&quot;));
                CHECK(accept_helper(&quot;\&quot;üéà\&quot;&quot;));

                CHECK(accept_helper(&quot;\&quot;\\ud80c\\udc60\&quot;&quot;));
                CHECK(accept_helper(&quot;\&quot;\\ud83c\\udf1e\&quot;&quot;));
            }
        }

        SECTION(&quot;number&quot;)
        {
            SECTION(&quot;integers&quot;)
            {
                SECTION(&quot;without exponent&quot;)
                {
                    CHECK(accept_helper(&quot;-128&quot;));
                    CHECK(accept_helper(&quot;-0&quot;));
                    CHECK(accept_helper(&quot;0&quot;));
                    CHECK(accept_helper(&quot;128&quot;));
                }

                SECTION(&quot;with exponent&quot;)
                {
                    CHECK(accept_helper(&quot;0e1&quot;));
                    CHECK(accept_helper(&quot;0E1&quot;));

                    CHECK(accept_helper(&quot;10000E-4&quot;));
                    CHECK(accept_helper(&quot;10000E-3&quot;));
                    CHECK(accept_helper(&quot;10000E-2&quot;));
                    CHECK(accept_helper(&quot;10000E-1&quot;));
                    CHECK(accept_helper(&quot;10000E0&quot;));
                    CHECK(accept_helper(&quot;10000E1&quot;));
                    CHECK(accept_helper(&quot;10000E2&quot;));
                    CHECK(accept_helper(&quot;10000E3&quot;));
                    CHECK(accept_helper(&quot;10000E4&quot;));

                    CHECK(accept_helper(&quot;10000e-4&quot;));
                    CHECK(accept_helper(&quot;10000e-3&quot;));
                    CHECK(accept_helper(&quot;10000e-2&quot;));
                    CHECK(accept_helper(&quot;10000e-1&quot;));
                    CHECK(accept_helper(&quot;10000e0&quot;));
                    CHECK(accept_helper(&quot;10000e1&quot;));
                    CHECK(accept_helper(&quot;10000e2&quot;));
                    CHECK(accept_helper(&quot;10000e3&quot;));
                    CHECK(accept_helper(&quot;10000e4&quot;));

                    CHECK(accept_helper(&quot;-0e1&quot;));
                    CHECK(accept_helper(&quot;-0E1&quot;));
                    CHECK(accept_helper(&quot;-0E123&quot;));
                }

                SECTION(&quot;edge cases&quot;)
                {
                    // From RFC8259, Section 6:
                    // Note that when such software is used, numbers that are
                    // integers and are in the range [-(2**53)+1, (2**53)-1]
                    // are interoperable in the sense that implementations will
                    // agree exactly on their numeric values.

                    // -(2**53)+1
                    CHECK(accept_helper(&quot;-9007199254740991&quot;));
                    // (2**53)-1
                    CHECK(accept_helper(&quot;9007199254740991&quot;));
                }

                SECTION(&quot;over the edge cases&quot;)  // issue #178 - Integer conversion to unsigned (incorrect handling of 64-bit integers)
                {
                    // While RFC8259, Section 6 specifies a preference for support
                    // for ranges in range of IEEE 754-2008 binary64 (double precision)
                    // this does not accommodate 64 bit integers without loss of accuracy.
                    // As 64 bit integers are now widely used in software, it is desirable
                    // to expand support to the full 64 bit (signed and unsigned) range
                    // i.e. -(2**63) -&gt; (2**64)-1.

                    // -(2**63)    ** Note: compilers see negative literals as negated positive numbers (hence the -1))
                    CHECK(accept_helper(&quot;-9223372036854775808&quot;));
                    // (2**63)-1
                    CHECK(accept_helper(&quot;9223372036854775807&quot;));
                    // (2**64)-1
                    CHECK(accept_helper(&quot;18446744073709551615&quot;));
                }
            }

            SECTION(&quot;floating-point&quot;)
            {
                SECTION(&quot;without exponent&quot;)
                {
                    CHECK(accept_helper(&quot;-128.5&quot;));
                    CHECK(accept_helper(&quot;0.999&quot;));
                    CHECK(accept_helper(&quot;128.5&quot;));
                    CHECK(accept_helper(&quot;-0.0&quot;));
                }

                SECTION(&quot;with exponent&quot;)
                {
                    CHECK(accept_helper(&quot;-128.5E3&quot;));
                    CHECK(accept_helper(&quot;-128.5E-3&quot;));
                    CHECK(accept_helper(&quot;-0.0e1&quot;));
                    CHECK(accept_helper(&quot;-0.0E1&quot;));
                }
            }

            SECTION(&quot;overflow&quot;)
            {
                // overflows during parsing
                CHECK(!accept_helper(&quot;1.18973e+4932&quot;));
            }

            SECTION(&quot;invalid numbers&quot;)
            {
                CHECK(accept_helper(&quot;01&quot;) == false);
                CHECK(accept_helper(&quot;--1&quot;) == false);
                CHECK(accept_helper(&quot;1.&quot;) == false);
                CHECK(accept_helper(&quot;1E&quot;) == false);
                CHECK(accept_helper(&quot;1E-&quot;) == false);
                CHECK(accept_helper(&quot;1.E1&quot;) == false);
                CHECK(accept_helper(&quot;-1E&quot;) == false);
                CHECK(accept_helper(&quot;-0E#&quot;) == false);
                CHECK(accept_helper(&quot;-0E-#&quot;) == false);
                CHECK(accept_helper(&quot;-0#&quot;) == false);
                CHECK(accept_helper(&quot;-0.0:&quot;) == false);
                CHECK(accept_helper(&quot;-0.0Z&quot;) == false);
                CHECK(accept_helper(&quot;-0E123:&quot;) == false);
                CHECK(accept_helper(&quot;-0e0-:&quot;) == false);
                CHECK(accept_helper(&quot;-0e-:&quot;) == false);
                CHECK(accept_helper(&quot;-0f&quot;) == false);

                // numbers must not begin with &quot;+&quot;
                CHECK(accept_helper(&quot;+1&quot;) == false);
                CHECK(accept_helper(&quot;+0&quot;) == false);
            }
        }
    }

    SECTION(&quot;parse errors&quot;)
    {
        // unexpected end of number
        CHECK_THROWS_WITH_AS(parser_helper(&quot;0.&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 3: syntax error while parsing value - invalid number; expected digit after &#39;.&#39;; last read: &#39;0.&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;-&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid number; expected digit after &#39;-&#39;; last read: &#39;-&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;--&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid number; expected digit after &#39;-&#39;; last read: &#39;--&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;-0.&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 4: syntax error while parsing value - invalid number; expected digit after &#39;.&#39;; last read: &#39;-0.&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;-.&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid number; expected digit after &#39;-&#39;; last read: &#39;-.&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;-:&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid number; expected digit after &#39;-&#39;; last read: &#39;-:&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;0.:&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 3: syntax error while parsing value - invalid number; expected digit after &#39;.&#39;; last read: &#39;0.:&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;e.&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 1: syntax error while parsing value - invalid literal; last read: &#39;e&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;1e.&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 3: syntax error while parsing value - invalid number; expected &#39;+&#39;, &#39;-&#39;, or digit after exponent; last read: &#39;1e.&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;1e/&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 3: syntax error while parsing value - invalid number; expected &#39;+&#39;, &#39;-&#39;, or digit after exponent; last read: &#39;1e/&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;1e:&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 3: syntax error while parsing value - invalid number; expected &#39;+&#39;, &#39;-&#39;, or digit after exponent; last read: &#39;1e:&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;1E.&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 3: syntax error while parsing value - invalid number; expected &#39;+&#39;, &#39;-&#39;, or digit after exponent; last read: &#39;1E.&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;1E/&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 3: syntax error while parsing value - invalid number; expected &#39;+&#39;, &#39;-&#39;, or digit after exponent; last read: &#39;1E/&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;1E:&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 3: syntax error while parsing value - invalid number; expected &#39;+&#39;, &#39;-&#39;, or digit after exponent; last read: &#39;1E:&#39;&quot;, json::parse_error&amp;);

        // unexpected end of null
        CHECK_THROWS_WITH_AS(parser_helper(&quot;n&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid literal; last read: &#39;n&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;nu&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 3: syntax error while parsing value - invalid literal; last read: &#39;nu&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;nul&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 4: syntax error while parsing value - invalid literal; last read: &#39;nul&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;nulk&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 4: syntax error while parsing value - invalid literal; last read: &#39;nulk&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;nulm&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 4: syntax error while parsing value - invalid literal; last read: &#39;nulm&#39;&quot;, json::parse_error&amp;);

        // unexpected end of true
        CHECK_THROWS_WITH_AS(parser_helper(&quot;t&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid literal; last read: &#39;t&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;tr&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 3: syntax error while parsing value - invalid literal; last read: &#39;tr&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;tru&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 4: syntax error while parsing value - invalid literal; last read: &#39;tru&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;trud&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 4: syntax error while parsing value - invalid literal; last read: &#39;trud&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;truf&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 4: syntax error while parsing value - invalid literal; last read: &#39;truf&#39;&quot;, json::parse_error&amp;);

        // unexpected end of false
        CHECK_THROWS_WITH_AS(parser_helper(&quot;f&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid literal; last read: &#39;f&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;fa&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 3: syntax error while parsing value - invalid literal; last read: &#39;fa&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;fal&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 4: syntax error while parsing value - invalid literal; last read: &#39;fal&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;fals&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 5: syntax error while parsing value - invalid literal; last read: &#39;fals&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;falsd&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 5: syntax error while parsing value - invalid literal; last read: &#39;falsd&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;falsf&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 5: syntax error while parsing value - invalid literal; last read: &#39;falsf&#39;&quot;, json::parse_error&amp;);

        // missing/unexpected end of array
        CHECK_THROWS_WITH_AS(parser_helper(&quot;[&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - unexpected end of input; expected &#39;[&#39;, &#39;{&#39;, or a literal&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;[1&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 3: syntax error while parsing array - unexpected end of input; expected &#39;]&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;[1,&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 4: syntax error while parsing value - unexpected end of input; expected &#39;[&#39;, &#39;{&#39;, or a literal&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;[1,]&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 4: syntax error while parsing value - unexpected &#39;]&#39;; expected &#39;[&#39;, &#39;{&#39;, or a literal&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;]&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 1: syntax error while parsing value - unexpected &#39;]&#39;; expected &#39;[&#39;, &#39;{&#39;, or a literal&quot;, json::parse_error&amp;);

        // missing/unexpected end of object
        CHECK_THROWS_WITH_AS(parser_helper(&quot;{&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing object key - unexpected end of input; expected string literal&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;{\&quot;foo\&quot;&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 7: syntax error while parsing object separator - unexpected end of input; expected &#39;:&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;{\&quot;foo\&quot;:&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 8: syntax error while parsing value - unexpected end of input; expected &#39;[&#39;, &#39;{&#39;, or a literal&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;{\&quot;foo\&quot;:}&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 8: syntax error while parsing value - unexpected &#39;}&#39;; expected &#39;[&#39;, &#39;{&#39;, or a literal&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;{\&quot;foo\&quot;:1,}&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 10: syntax error while parsing object key - unexpected &#39;}&#39;; expected string literal&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;}&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 1: syntax error while parsing value - unexpected &#39;}&#39;; expected &#39;[&#39;, &#39;{&#39;, or a literal&quot;, json::parse_error&amp;);

        // missing/unexpected end of string
        CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: missing closing quote; last read: &#39;\&quot;&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\\\&quot;&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 4: syntax error while parsing value - invalid string: missing closing quote; last read: &#39;\&quot;\\\&quot;&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\\u\&quot;&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 4: syntax error while parsing value - invalid string: &#39;\\u&#39; must be followed by 4 hex digits; last read: &#39;\&quot;\\u\&quot;&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\\u0\&quot;&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 5: syntax error while parsing value - invalid string: &#39;\\u&#39; must be followed by 4 hex digits; last read: &#39;\&quot;\\u0\&quot;&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\\u01\&quot;&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 6: syntax error while parsing value - invalid string: &#39;\\u&#39; must be followed by 4 hex digits; last read: &#39;\&quot;\\u01\&quot;&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\\u012\&quot;&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 7: syntax error while parsing value - invalid string: &#39;\\u&#39; must be followed by 4 hex digits; last read: &#39;\&quot;\\u012\&quot;&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\\u&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 4: syntax error while parsing value - invalid string: &#39;\\u&#39; must be followed by 4 hex digits; last read: &#39;\&quot;\\u&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\\u0&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 5: syntax error while parsing value - invalid string: &#39;\\u&#39; must be followed by 4 hex digits; last read: &#39;\&quot;\\u0&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\\u01&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 6: syntax error while parsing value - invalid string: &#39;\\u&#39; must be followed by 4 hex digits; last read: &#39;\&quot;\\u01&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(parser_helper(&quot;\&quot;\\u012&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 7: syntax error while parsing value - invalid string: &#39;\\u&#39; must be followed by 4 hex digits; last read: &#39;\&quot;\\u012&#39;&quot;, json::parse_error&amp;);

        // invalid escapes
        for (int c = 1; c &lt; 128; ++c)
        {
            auto s = std::string(&quot;\&quot;\\&quot;) + std::string(1, static_cast&lt;char&gt;(c)) + &quot;\&quot;&quot;;

            switch (c)
            {
                // valid escapes
                case (&#39;&quot;&#39;):
                case (&#39;\\&#39;):
                case (&#39;/&#39;):
                case (&#39;b&#39;):
                case (&#39;f&#39;):
                case (&#39;n&#39;):
                case (&#39;r&#39;):
                case (&#39;t&#39;):
                {
                    CHECK_NOTHROW(parser_helper(s));
                    break;
                }

                // \u must be followed with four numbers, so we skip it here
                case (&#39;u&#39;):
                {
                    break;
                }

                // any other combination of backslash and character is invalid
                default:
                {
                    CHECK_THROWS_AS(parser_helper(s), json::parse_error&amp;);
                    // only check error message if c is not a control character
                    if (c &gt; 0x1f)
                    {
                        CHECK_THROWS_WITH_STD_STR(parser_helper(s),
                                                  &quot;[json.exception.parse_error.101] parse error at line 1, column 3: syntax error while parsing value - invalid string: forbidden character after backslash; last read: &#39;\&quot;\\&quot; + std::string(1, static_cast&lt;char&gt;(c)) + &quot;&#39;&quot;);
                    }
                    break;
                }
            }
        }

        // invalid \uxxxx escapes
        {
            // check whether character is a valid hex character
            const auto valid = [](int c)
            {
                switch (c)
                {
                    case (&#39;0&#39;):
                    case (&#39;1&#39;):
                    case (&#39;2&#39;):
                    case (&#39;3&#39;):
                    case (&#39;4&#39;):
                    case (&#39;5&#39;):
                    case (&#39;6&#39;):
                    case (&#39;7&#39;):
                    case (&#39;8&#39;):
                    case (&#39;9&#39;):
                    case (&#39;a&#39;):
                    case (&#39;b&#39;):
                    case (&#39;c&#39;):
                    case (&#39;d&#39;):
                    case (&#39;e&#39;):
                    case (&#39;f&#39;):
                    case (&#39;A&#39;):
                    case (&#39;B&#39;):
                    case (&#39;C&#39;):
                    case (&#39;D&#39;):
                    case (&#39;E&#39;):
                    case (&#39;F&#39;):
                    {
                        return true;
                    }

                    default:
                    {
                        return false;
                    }
                }
            };

            for (int c = 1; c &lt; 128; ++c)
            {
                std::string const s = &quot;\&quot;\\u&quot;;

                // create a string with the iterated character at each position
                auto s1 = s + &quot;000&quot; + std::string(1, static_cast&lt;char&gt;(c)) + &quot;\&quot;&quot;;
                auto s2 = s + &quot;00&quot; + std::string(1, static_cast&lt;char&gt;(c)) + &quot;0\&quot;&quot;;
                auto s3 = s + &quot;0&quot; + std::string(1, static_cast&lt;char&gt;(c)) + &quot;00\&quot;&quot;;
                auto s4 = s + std::string(1, static_cast&lt;char&gt;(c)) + &quot;000\&quot;&quot;;

                if (valid(c))
                {
                    CAPTURE(s1)
                    CHECK_NOTHROW(parser_helper(s1));
                    CAPTURE(s2)
                    CHECK_NOTHROW(parser_helper(s2));
                    CAPTURE(s3)
                    CHECK_NOTHROW(parser_helper(s3));
                    CAPTURE(s4)
                    CHECK_NOTHROW(parser_helper(s4));
                }
                else
                {
                    CAPTURE(s1)
                    CHECK_THROWS_AS(parser_helper(s1), json::parse_error&amp;);
                    // only check error message if c is not a control character
                    if (c &gt; 0x1f)
                    {
                        CHECK_THROWS_WITH_STD_STR(parser_helper(s1),
                                                  &quot;[json.exception.parse_error.101] parse error at line 1, column 7: syntax error while parsing value - invalid string: &#39;\\u&#39; must be followed by 4 hex digits; last read: &#39;&quot; + s1.substr(0, 7) + &quot;&#39;&quot;);
                    }

                    CAPTURE(s2)
                    CHECK_THROWS_AS(parser_helper(s2), json::parse_error&amp;);
                    // only check error message if c is not a control character
                    if (c &gt; 0x1f)
                    {
                        CHECK_THROWS_WITH_STD_STR(parser_helper(s2),
                                                  &quot;[json.exception.parse_error.101] parse error at line 1, column 6: syntax error while parsing value - invalid string: &#39;\\u&#39; must be followed by 4 hex digits; last read: &#39;&quot; + s2.substr(0, 6) + &quot;&#39;&quot;);
                    }

                    CAPTURE(s3)
                    CHECK_THROWS_AS(parser_helper(s3), json::parse_error&amp;);
                    // only check error message if c is not a control character
                    if (c &gt; 0x1f)
                    {
                        CHECK_THROWS_WITH_STD_STR(parser_helper(s3),
                                                  &quot;[json.exception.parse_error.101] parse error at line 1, column 5: syntax error while parsing value - invalid string: &#39;\\u&#39; must be followed by 4 hex digits; last read: &#39;&quot; + s3.substr(0, 5) + &quot;&#39;&quot;);
                    }

                    CAPTURE(s4)
                    CHECK_THROWS_AS(parser_helper(s4), json::parse_error&amp;);
                    // only check error message if c is not a control character
                    if (c &gt; 0x1f)
                    {
                        CHECK_THROWS_WITH_STD_STR(parser_helper(s4),
                                                  &quot;[json.exception.parse_error.101] parse error at line 1, column 4: syntax error while parsing value - invalid string: &#39;\\u&#39; must be followed by 4 hex digits; last read: &#39;&quot; + s4.substr(0, 4) + &quot;&#39;&quot;);
                    }
                }
            }
        }

        json _;

        // missing part of a surrogate pair
        CHECK_THROWS_WITH_AS(_ = json::parse(&quot;\&quot;\\uD80C\&quot;&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 8: syntax error while parsing value - invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF; last read: &#39;\&quot;\\uD80C\&quot;&#39;&quot;, json::parse_error&amp;);
        // invalid surrogate pair
        CHECK_THROWS_WITH_AS(_ = json::parse(&quot;\&quot;\\uD80C\\uD80C\&quot;&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 13: syntax error while parsing value - invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF; last read: &#39;\&quot;\\uD80C\\uD80C&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(_ = json::parse(&quot;\&quot;\\uD80C\\u0000\&quot;&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 13: syntax error while parsing value - invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF; last read: &#39;\&quot;\\uD80C\\u0000&#39;&quot;, json::parse_error&amp;);
        CHECK_THROWS_WITH_AS(_ = json::parse(&quot;\&quot;\\uD80C\\uFFFF\&quot;&quot;),
                             &quot;[json.exception.parse_error.101] parse error at line 1, column 13: syntax error while parsing value - invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF; last read: &#39;\&quot;\\uD80C\\uFFFF&#39;&quot;, json::parse_error&amp;);
    }

    SECTION(&quot;parse errors (accept)&quot;)
    {
        // unexpected end of number
        CHECK(accept_helper(&quot;0.&quot;) == false);
        CHECK(accept_helper(&quot;-&quot;) == false);
        CHECK(accept_helper(&quot;--&quot;) == false);
        CHECK(accept_helper(&quot;-0.&quot;) == false);
        CHECK(accept_helper(&quot;-.&quot;) == false);
        CHECK(accept_helper(&quot;-:&quot;) == false);
        CHECK(accept_helper(&quot;0.:&quot;) == false);
        CHECK(accept_helper(&quot;e.&quot;) == false);
        CHECK(accept_helper(&quot;1e.&quot;) == false);
        CHECK(accept_helper(&quot;1e/&quot;) == false);
        CHECK(accept_helper(&quot;1e:&quot;) == false);
        CHECK(accept_helper(&quot;1E.&quot;) == false);
        CHECK(accept_helper(&quot;1E/&quot;) == false);
        CHECK(accept_helper(&quot;1E:&quot;) == false);

        // unexpected end of null
        CHECK(accept_helper(&quot;n&quot;) == false);
        CHECK(accept_helper(&quot;nu&quot;) == false);
        CHECK(accept_helper(&quot;nul&quot;) == false);

        // unexpected end of true
        CHECK(accept_helper(&quot;t&quot;) == false);
        CHECK(accept_helper(&quot;tr&quot;) == false);
        CHECK(accept_helper(&quot;tru&quot;) == false);

        // unexpected end of false
        CHECK(accept_helper(&quot;f&quot;) == false);
        CHECK(accept_helper(&quot;fa&quot;) == false);
        CHECK(accept_helper(&quot;fal&quot;) == false);
        CHECK(accept_helper(&quot;fals&quot;) == false);

        // missing/unexpected end of array
        CHECK(accept_helper(&quot;[&quot;) == false);
        CHECK(accept_helper(&quot;[1&quot;) == false);
        CHECK(accept_helper(&quot;[1,&quot;) == false);
        CHECK(accept_helper(&quot;[1,]&quot;) == false);
        CHECK(accept_helper(&quot;]&quot;) == false);

        // missing/unexpected end of object
        CHECK(accept_helper(&quot;{&quot;) == false);
        CHECK(accept_helper(&quot;{\&quot;foo\&quot;&quot;) == false);
        CHECK(accept_helper(&quot;{\&quot;foo\&quot;:&quot;) == false);
        CHECK(accept_helper(&quot;{\&quot;foo\&quot;:}&quot;) == false);
        CHECK(accept_helper(&quot;{\&quot;foo\&quot;:1,}&quot;) == false);
        CHECK(accept_helper(&quot;}&quot;) == false);

        // missing/unexpected end of string
        CHECK(accept_helper(&quot;\&quot;&quot;) == false);
        CHECK(accept_helper(&quot;\&quot;\\\&quot;&quot;) == false);
        CHECK(accept_helper(&quot;\&quot;\\u\&quot;&quot;) == false);
        CHECK(accept_helper(&quot;\&quot;\\u0\&quot;&quot;) == false);
        CHECK(accept_helper(&quot;\&quot;\\u01\&quot;&quot;) == false);
        CHECK(accept_helper(&quot;\&quot;\\u012\&quot;&quot;) == false);
        CHECK(accept_helper(&quot;\&quot;\\u&quot;) == false);
        CHECK(accept_helper(&quot;\&quot;\\u0&quot;) == false);
        CHECK(accept_helper(&quot;\&quot;\\u01&quot;) == false);
        CHECK(accept_helper(&quot;\&quot;\\u012&quot;) == false);

        // unget of newline
        CHECK(parser_helper(&quot;\n123\n&quot;) == 123);

        // invalid escapes
        for (int c = 1; c &lt; 128; ++c)
        {
            auto s = std::string(&quot;\&quot;\\&quot;) + std::string(1, static_cast&lt;char&gt;(c)) + &quot;\&quot;&quot;;

            switch (c)
            {
                // valid escapes
                case (&#39;&quot;&#39;):
                case (&#39;\\&#39;):
                case (&#39;/&#39;):
                case (&#39;b&#39;):
                case (&#39;f&#39;):
                case (&#39;n&#39;):
                case (&#39;r&#39;):
                case (&#39;t&#39;):
                {
                    CHECK(json::parser(nlohmann::detail::input_adapter(s)).accept());
                    break;
                }

                // \u must be followed with four numbers, so we skip it here
                case (&#39;u&#39;):
                {
                    break;
                }

                // any other combination of backslash and character is invalid
                default:
                {
                    CHECK(json::parser(nlohmann::detail::input_adapter(s)).accept() == false);
                    break;
                }
            }
        }

        // invalid \uxxxx escapes
        {
            // check whether character is a valid hex character
            const auto valid = [](int c)
            {
                switch (c)
                {
                    case (&#39;0&#39;):
                    case (&#39;1&#39;):
                    case (&#39;2&#39;):
                    case (&#39;3&#39;):
                    case (&#39;4&#39;):
                    case (&#39;5&#39;):
                    case (&#39;6&#39;):
                    case (&#39;7&#39;):
                    case (&#39;8&#39;):
                    case (&#39;9&#39;):
                    case (&#39;a&#39;):
                    case (&#39;b&#39;):
                    case (&#39;c&#39;):
                    case (&#39;d&#39;):
                    case (&#39;e&#39;):
                    case (&#39;f&#39;):
                    case (&#39;A&#39;):
                    case (&#39;B&#39;):
                    case (&#39;C&#39;):
                    case (&#39;D&#39;):
                    case (&#39;E&#39;):
                    case (&#39;F&#39;):
                    {
                        return true;
                    }

                    default:
                    {
                        return false;
                    }
                }
            };

            for (int c = 1; c &lt; 128; ++c)
            {
                std::string const s = &quot;\&quot;\\u&quot;;

                // create a string with the iterated character at each position
                const auto s1 = s + &quot;000&quot; + std::string(1, static_cast&lt;char&gt;(c)) + &quot;\&quot;&quot;;
                const auto s2 = s + &quot;00&quot; + std::string(1, static_cast&lt;char&gt;(c)) + &quot;0\&quot;&quot;;
                const auto s3 = s + &quot;0&quot; + std::string(1, static_cast&lt;char&gt;(c)) + &quot;00\&quot;&quot;;
                const auto s4 = s + std::string(1, static_cast&lt;char&gt;(c)) + &quot;000\&quot;&quot;;

                if (valid(c))
                {
                    CAPTURE(s1)
                    CHECK(json::parser(nlohmann::detail::input_adapter(s1)).accept());
                    CAPTURE(s2)
                    CHECK(json::parser(nlohmann::detail::input_adapter(s2)).accept());
                    CAPTURE(s3)
                    CHECK(json::parser(nlohmann::detail::input_adapter(s3)).accept());
                    CAPTURE(s4)
                    CHECK(json::parser(nlohmann::detail::input_adapter(s4)).accept());
                }
                else
                {
                    CAPTURE(s1)
                    CHECK(json::parser(nlohmann::detail::input_adapter(s1)).accept() == false);

                    CAPTURE(s2)
                    CHECK(json::parser(nlohmann::detail::input_adapter(s2)).accept() == false);

                    CAPTURE(s3)
                    CHECK(json::parser(nlohmann::detail::input_adapter(s3)).accept() == false);

                    CAPTURE(s4)
                    CHECK(json::parser(nlohmann::detail::input_adapter(s4)).accept() == false);
                }
            }
        }

        // missing part of a surrogate pair
        CHECK(accept_helper(&quot;\&quot;\\uD80C\&quot;&quot;) == false);
        // invalid surrogate pair
        CHECK(accept_helper(&quot;\&quot;\\uD80C\\uD80C\&quot;&quot;) == false);
        CHECK(accept_helper(&quot;\&quot;\\uD80C\\u0000\&quot;&quot;) == false);
        CHECK(accept_helper(&quot;\&quot;\\uD80C\\uFFFF\&quot;&quot;) == false);
    }

    SECTION(&quot;tests found by mutate++&quot;)
    {
        // test case to make sure no comma precedes the first key
        CHECK_THROWS_WITH_AS(parser_helper(&quot;{,\&quot;key\&quot;: false}&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing object key - unexpected &#39;,&#39;; expected string literal&quot;, json::parse_error&amp;);
        // test case to make sure an object is properly closed
        CHECK_THROWS_WITH_AS(parser_helper(&quot;[{\&quot;key\&quot;: false true]&quot;), &quot;[json.exception.parse_error.101] parse error at line 1, column 19: syntax error while parsing object - unexpected true literal; expected &#39;}&#39;&quot;, json::parse_error&amp;);

        // test case to make sure the callback is properly evaluated after reading a key
        {
            json::parser_callback_t const cb = [](int /*unused*/, json::parse_event_t event, json&amp; /*unused*/) noexcept
            {
                return event != json::parse_event_t::key;
            };

            json x = json::parse(&quot;{\&quot;key\&quot;: false}&quot;, cb);
            CHECK(x == json::object());
        }
    }

    SECTION(&quot;callback function&quot;)
    {
        const auto* s_object = R&quot;(
            {
                &quot;foo&quot;: 2,
                &quot;bar&quot;: {
                    &quot;baz&quot;: 1
                }
            }
        )&quot;;

        const auto* s_array = R&quot;(
            [1,2,[3,4,5],4,5]
        )&quot;;

        const auto* structured_array = R&quot;(
            [
                1,
                {
                     &quot;foo&quot;: &quot;bar&quot;
                },
                {
                     &quot;qux&quot;: &quot;baz&quot;
                }
            ]
        )&quot;;

        SECTION(&quot;filter nothing&quot;)
        {
            json j_object = json::parse(s_object, [](int /*unused*/, json::parse_event_t /*unused*/, const json&amp; /*unused*/) noexcept
            {
                return true;
            });

            CHECK (j_object == json({{&quot;foo&quot;, 2}, {&quot;bar&quot;, {{&quot;baz&quot;, 1}}}}));

            json j_array = json::parse(s_array, [](int /*unused*/, json::parse_event_t /*unused*/, const json&amp; /*unused*/) noexcept
            {
                return true;
            });

            CHECK (j_array == json({1, 2, {3, 4, 5}, 4, 5}));
        }

        SECTION(&quot;filter everything&quot;)
        {
            json const j_object = json::parse(s_object, [](int /*unused*/, json::parse_event_t /*unused*/, const json&amp; /*unused*/) noexcept
            {
                return false;
            });

            // the top-level object will be discarded, leaving a null
            CHECK (j_object.is_null());

            json const j_array = json::parse(s_array, [](int /*unused*/, json::parse_event_t /*unused*/, const json&amp; /*unused*/) noexcept
            {
                return false;
            });

            // the top-level array will be discarded, leaving a null
            CHECK (j_array.is_null());
        }

        SECTION(&quot;filter specific element&quot;)
        {
            json j_object = json::parse(s_object, [](int /*unused*/, json::parse_event_t event, const json &amp; j) noexcept
            {
                // filter all number(2) elements
                return event != json::parse_event_t::value || j != json(2);
            });

            CHECK (j_object == json({{&quot;bar&quot;, {{&quot;baz&quot;, 1}}}}));

            json j_array = json::parse(s_array, [](int /*unused*/, json::parse_event_t event, const json &amp; j) noexcept
            {
                return event != json::parse_event_t::value || j != json(2);
            });

            CHECK (j_array == json({1, {3, 4, 5}, 4, 5}));
        }

        SECTION(&quot;filter object in array&quot;)
        {
            json j_filtered1 = json::parse(structured_array, [](int /*unused*/, json::parse_event_t e, const json &amp; parsed)
            {
                return !(e == json::parse_event_t::object_end &amp;&amp; parsed.contains(&quot;foo&quot;));
            });

            // the specified object will be discarded, and removed.
            CHECK (j_filtered1.size() == 2);
            CHECK (j_filtered1 == json({1, {{&quot;qux&quot;, &quot;baz&quot;}}}));

            json j_filtered2 = json::parse(structured_array, [](int /*unused*/, json::parse_event_t e, const json&amp; /*parsed*/) noexcept
            {
                return e != json::parse_event_t::object_end;
            });

            // removed all objects in array.
            CHECK (j_filtered2.size() == 1);
            CHECK (j_filtered2 == json({1}));
        }

        SECTION(&quot;filter specific events&quot;)
        {
            SECTION(&quot;first closing event&quot;)
            {
                {
                    json j_object = json::parse(s_object, [](int /*unused*/, json::parse_event_t e, const json&amp; /*unused*/) noexcept
                    {
                        static bool first = true;
                        if (e == json::parse_event_t::object_end &amp;&amp; first)
                        {
                            first = false;
                            return false;
                        }

                        return true;
                    });

                    // the first completed object will be discarded
                    CHECK (j_object == json({{&quot;foo&quot;, 2}}));
                }

                {
                    json j_array = json::parse(s_array, [](int /*unused*/, json::parse_event_t e, const json&amp; /*unused*/) noexcept
                    {
                        static bool first = true;
                        if (e == json::parse_event_t::array_end &amp;&amp; first)
                        {
                            first = false;
                            return false;
                        }

                        return true;
                    });

                    // the first completed array will be discarded
                    CHECK (j_array == json({1, 2, 4, 5}));
                }
            }
        }

        SECTION(&quot;special cases&quot;)
        {
            // the following test cases cover the situation in which an empty
            // object and array is discarded only after the closing character
            // has been read

            json j_empty_object = json::parse(&quot;{}&quot;, [](int /*unused*/, json::parse_event_t e, const json&amp; /*unused*/) noexcept
            {
                return e != json::parse_event_t::object_end;
            });
            CHECK(j_empty_object == json());

            json j_empty_array = json::parse(&quot;[]&quot;, [](int /*unused*/, json::parse_event_t e, const json&amp; /*unused*/) noexcept
            {
                return e != json::parse_event_t::array_end;
            });
            CHECK(j_empty_array == json());
        }
    }

    SECTION(&quot;constructing from contiguous containers&quot;)
    {
        SECTION(&quot;from std::vector&quot;)
        {
            std::vector&lt;uint8_t&gt; v = {&#39;t&#39;, &#39;r&#39;, &#39;u&#39;, &#39;e&#39;};
            json j;
            json::parser(nlohmann::detail::input_adapter(std::begin(v), std::end(v))).parse(true, j);
            CHECK(j == json(true));
        }

        SECTION(&quot;from std::array&quot;)
        {
            std::array&lt;uint8_t, 5&gt; v { {&#39;t&#39;, &#39;r&#39;, &#39;u&#39;, &#39;e&#39;} };
            json j;
            json::parser(nlohmann::detail::input_adapter(std::begin(v), std::end(v))).parse(true, j);
            CHECK(j == json(true));
        }

        SECTION(&quot;from array&quot;)
        {
            uint8_t v[] = {&#39;t&#39;, &#39;r&#39;, &#39;u&#39;, &#39;e&#39;}; // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
            json j;
            json::parser(nlohmann::detail::input_adapter(std::begin(v), std::end(v))).parse(true, j);
            CHECK(j == json(true));
        }

        SECTION(&quot;from char literal&quot;)
        {
            CHECK(parser_helper(&quot;true&quot;) == json(true));
        }

        SECTION(&quot;from std::string&quot;)
        {
            std::string v = {&#39;t&#39;, &#39;r&#39;, &#39;u&#39;, &#39;e&#39;};
            json j;
            json::parser(nlohmann::detail::input_adapter(std::begin(v), std::end(v))).parse(true, j);
            CHECK(j == json(true));
        }

        SECTION(&quot;from std::initializer_list&quot;)
        {
            std::initializer_list&lt;uint8_t&gt; const v = {&#39;t&#39;, &#39;r&#39;, &#39;u&#39;, &#39;e&#39;};
            json j;
            json::parser(nlohmann::detail::input_adapter(std::begin(v), std::end(v))).parse(true, j);
            CHECK(j == json(true));
        }

        SECTION(&quot;from std::valarray&quot;)
        {
            std::valarray&lt;uint8_t&gt; v = {&#39;t&#39;, &#39;r&#39;, &#39;u&#39;, &#39;e&#39;};
            json j;
            json::parser(nlohmann::detail::input_adapter(std::begin(v), std::end(v))).parse(true, j);
            CHECK(j == json(true));
        }
    }

    SECTION(&quot;improve test coverage&quot;)
    {
        SECTION(&quot;parser with callback&quot;)
        {
            json::parser_callback_t const cb = [](int /*unused*/, json::parse_event_t /*unused*/, json&amp; /*unused*/) noexcept
            {
                return true;
            };

            CHECK(json::parse(&quot;{\&quot;foo\&quot;: true:&quot;, cb, false).is_discarded());

            json _;
            CHECK_THROWS_WITH_AS(_ = json::parse(&quot;{\&quot;foo\&quot;: true:&quot;, cb), &quot;[json.exception.parse_error.101] parse error at line 1, column 13: syntax error while parsing object - unexpected &#39;:&#39;; expected &#39;}&#39;&quot;, json::parse_error&amp;);

            CHECK_THROWS_WITH_AS(_ = json::parse(&quot;1.18973e+4932&quot;, cb), &quot;[json.exception.out_of_range.406] number overflow parsing &#39;1.18973e+4932&#39;&quot;, json::out_of_range&amp;);
        }

        SECTION(&quot;SAX parser&quot;)
        {
            SECTION(&quot;} without value&quot;)
            {
                SaxCountdown s(1);
                CHECK(json::sax_parse(&quot;{}&quot;, &amp;s) == false);
            }

            SECTION(&quot;} with value&quot;)
            {
                SaxCountdown s(3);
                CHECK(json::sax_parse(&quot;{\&quot;k1\&quot;: true}&quot;, &amp;s) == false);
            }

            SECTION(&quot;second key&quot;)
            {
                SaxCountdown s(3);
                CHECK(json::sax_parse(&quot;{\&quot;k1\&quot;: true, \&quot;k2\&quot;: false}&quot;, &amp;s) == false);
            }

            SECTION(&quot;] without value&quot;)
            {
                SaxCountdown s(1);
                CHECK(json::sax_parse(&quot;[]&quot;, &amp;s) == false);
            }

            SECTION(&quot;] with value&quot;)
            {
                SaxCountdown s(2);
                CHECK(json::sax_parse(&quot;[1]&quot;, &amp;s) == false);
            }

            SECTION(&quot;float&quot;)
            {
                SaxCountdown s(0);
                CHECK(json::sax_parse(&quot;3.14&quot;, &amp;s) == false);
            }

            SECTION(&quot;false&quot;)
            {
                SaxCountdown s(0);
                CHECK(json::sax_parse(&quot;false&quot;, &amp;s) == false);
            }

            SECTION(&quot;null&quot;)
            {
                SaxCountdown s(0);
                CHECK(json::sax_parse(&quot;null&quot;, &amp;s) == false);
            }

            SECTION(&quot;true&quot;)
            {
                SaxCountdown s(0);
                CHECK(json::sax_parse(&quot;true&quot;, &amp;s) == false);
            }

            SECTION(&quot;unsigned&quot;)
            {
                SaxCountdown s(0);
                CHECK(json::sax_parse(&quot;12&quot;, &amp;s) == false);
            }

            SECTION(&quot;integer&quot;)
            {
                SaxCountdown s(0);
                CHECK(json::sax_parse(&quot;-12&quot;, &amp;s) == false);
            }

            SECTION(&quot;string&quot;)
            {
                SaxCountdown s(0);
                CHECK(json::sax_parse(&quot;\&quot;foo\&quot;&quot;, &amp;s) == false);
            }
        }
    }

    SECTION(&quot;error messages for comments&quot;)
    {
        json _;
        CHECK_THROWS_WITH_AS(_ = json::parse(&quot;/a&quot;, nullptr, true, true), &quot;[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid comment; expecting &#39;/&#39; or &#39;*&#39; after &#39;/&#39;; last read: &#39;/a&#39;&quot;, json::parse_error);
        CHECK_THROWS_WITH_AS(_ = json::parse(&quot;/*&quot;, nullptr, true, true), &quot;[json.exception.parse_error.101] parse error at line 1, column 3: syntax error while parsing value - invalid comment; missing closing &#39;*/&#39;; last read: &#39;/*&lt;U+0000&gt;&#39;&quot;, json::parse_error);
    }
}

````
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;localplugins.WebReference</span> <span class="pre">object</span> <span class="pre">at</span> <span class="pre">0x71e76c970b50&gt;</span></code></p>
<blockquote>
<div><p>??? ‚ÄúClick to view reference‚Äù</p>
</div></blockquote>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>`gitlab.com`
</pre></div>
</div>
</li>
</ul>
<p>{% endraw %}</p>
<p><strong>Fallacies:</strong></p>
<p><em>None</em></p>
</section>
</section>


                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="TT.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">TT</p>
      </div>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#wfj-01">WFJ-01</a></li>
</ul>
  </nav></div>

  <div class="sidebar-secondary-item">

  
  <div class="tocsection editthispage">
    <a href="https://github.com/score-json/json/edit/main/docs/s-core/trustable/trudag/m2r2_test/WFJ.rst">
      <i class="fa-solid fa-pencil"></i>
      
      
        
          Edit on GitHub
        
      
    </a>
  </div>
</div>

  <div class="sidebar-secondary-item">
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../../_sources/s-core/trustable/trudag/m2r2_test/WFJ.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>